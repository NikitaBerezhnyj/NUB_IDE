{"ast":null,"code":"import { listen, TauriEvent, emit, once } from './event.js';\n\n// Copyright 2019-2023 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n/**\n * Customize the auto updater flow.\n *\n * This package is also accessible with `window.__TAURI__.updater` when [`build.withGlobalTauri`](https://tauri.app/v1/api/config/#buildconfig.withglobaltauri) in `tauri.conf.json` is set to `true`.\n * @module\n */\n/**\n * Listen to an updater event.\n * @example\n * ```typescript\n * import { onUpdaterEvent } from \"@tauri-apps/api/updater\";\n * const unlisten = await onUpdaterEvent(({ error, status }) => {\n *  console.log('Updater event', error, status);\n * });\n *\n * // you need to call unlisten if your handler goes out of scope e.g. the component is unmounted\n * unlisten();\n * ```\n *\n * @returns A promise resolving to a function to unlisten to the event.\n * Note that removing the listener is required if your listener goes out of scope e.g. the component is unmounted.\n *\n * @since 1.0.2\n */\nasync function onUpdaterEvent(handler) {\n  return listen(TauriEvent.STATUS_UPDATE, data => {\n    handler(data?.payload);\n  });\n}\n/**\n * Install the update if there's one available.\n * @example\n * ```typescript\n * import { checkUpdate, installUpdate } from '@tauri-apps/api/updater';\n * const update = await checkUpdate();\n * if (update.shouldUpdate) {\n *   console.log(`Installing update ${update.manifest?.version}, ${update.manifest?.date}, ${update.manifest.body}`);\n *   await installUpdate();\n * }\n * ```\n *\n * @return A promise indicating the success or failure of the operation.\n *\n * @since 1.0.0\n */\nasync function installUpdate() {\n  let unlistenerFn;\n  function cleanListener() {\n    if (unlistenerFn) {\n      unlistenerFn();\n    }\n    unlistenerFn = undefined;\n  }\n  return new Promise((resolve, reject) => {\n    function onStatusChange(statusResult) {\n      if (statusResult.error) {\n        cleanListener();\n        reject(statusResult.error);\n        return;\n      }\n      // install complete\n      if (statusResult.status === 'DONE') {\n        cleanListener();\n        resolve();\n      }\n    }\n    // listen status change\n    onUpdaterEvent(onStatusChange).then(fn => {\n      unlistenerFn = fn;\n    }).catch(e => {\n      cleanListener();\n      // dispatch the error to our checkUpdate\n      throw e;\n    });\n    // start the process we dont require much security as it's\n    // handled by rust\n    emit(TauriEvent.INSTALL_UPDATE).catch(e => {\n      cleanListener();\n      // dispatch the error to our checkUpdate\n      throw e;\n    });\n  });\n}\n/**\n * Checks if an update is available.\n * @example\n * ```typescript\n * import { checkUpdate } from '@tauri-apps/api/updater';\n * const update = await checkUpdate();\n * // now run installUpdate() if needed\n * ```\n *\n * @return Promise resolving to the update status.\n *\n * @since 1.0.0\n */\nasync function checkUpdate() {\n  let unlistenerFn;\n  function cleanListener() {\n    if (unlistenerFn) {\n      unlistenerFn();\n    }\n    unlistenerFn = undefined;\n  }\n  return new Promise((resolve, reject) => {\n    function onUpdateAvailable(manifest) {\n      cleanListener();\n      resolve({\n        manifest,\n        shouldUpdate: true\n      });\n    }\n    function onStatusChange(statusResult) {\n      if (statusResult.error) {\n        cleanListener();\n        reject(statusResult.error);\n        return;\n      }\n      if (statusResult.status === 'UPTODATE') {\n        cleanListener();\n        resolve({\n          shouldUpdate: false\n        });\n      }\n    }\n    // wait to receive the latest update\n    once(TauriEvent.UPDATE_AVAILABLE, data => {\n      onUpdateAvailable(data?.payload);\n    }).catch(e => {\n      cleanListener();\n      // dispatch the error to our checkUpdate\n      throw e;\n    });\n    // listen status change\n    onUpdaterEvent(onStatusChange).then(fn => {\n      unlistenerFn = fn;\n    }).catch(e => {\n      cleanListener();\n      // dispatch the error to our checkUpdate\n      throw e;\n    });\n    // start the process\n    emit(TauriEvent.CHECK_UPDATE).catch(e => {\n      cleanListener();\n      // dispatch the error to our checkUpdate\n      throw e;\n    });\n  });\n}\nexport { checkUpdate, installUpdate, onUpdaterEvent };","map":{"version":3,"names":["listen","TauriEvent","emit","once","onUpdaterEvent","handler","STATUS_UPDATE","data","payload","installUpdate","unlistenerFn","cleanListener","undefined","Promise","resolve","reject","onStatusChange","statusResult","error","status","then","fn","catch","e","INSTALL_UPDATE","checkUpdate","onUpdateAvailable","manifest","shouldUpdate","UPDATE_AVAILABLE","CHECK_UPDATE"],"sources":["/home/nikita/Проєкти/Rust/nub-ide/node_modules/@tauri-apps/api/updater.js"],"sourcesContent":["import { listen, TauriEvent, emit, once } from './event.js';\n\n// Copyright 2019-2023 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n/**\n * Customize the auto updater flow.\n *\n * This package is also accessible with `window.__TAURI__.updater` when [`build.withGlobalTauri`](https://tauri.app/v1/api/config/#buildconfig.withglobaltauri) in `tauri.conf.json` is set to `true`.\n * @module\n */\n/**\n * Listen to an updater event.\n * @example\n * ```typescript\n * import { onUpdaterEvent } from \"@tauri-apps/api/updater\";\n * const unlisten = await onUpdaterEvent(({ error, status }) => {\n *  console.log('Updater event', error, status);\n * });\n *\n * // you need to call unlisten if your handler goes out of scope e.g. the component is unmounted\n * unlisten();\n * ```\n *\n * @returns A promise resolving to a function to unlisten to the event.\n * Note that removing the listener is required if your listener goes out of scope e.g. the component is unmounted.\n *\n * @since 1.0.2\n */\nasync function onUpdaterEvent(handler) {\n    return listen(TauriEvent.STATUS_UPDATE, (data) => {\n        handler(data?.payload);\n    });\n}\n/**\n * Install the update if there's one available.\n * @example\n * ```typescript\n * import { checkUpdate, installUpdate } from '@tauri-apps/api/updater';\n * const update = await checkUpdate();\n * if (update.shouldUpdate) {\n *   console.log(`Installing update ${update.manifest?.version}, ${update.manifest?.date}, ${update.manifest.body}`);\n *   await installUpdate();\n * }\n * ```\n *\n * @return A promise indicating the success or failure of the operation.\n *\n * @since 1.0.0\n */\nasync function installUpdate() {\n    let unlistenerFn;\n    function cleanListener() {\n        if (unlistenerFn) {\n            unlistenerFn();\n        }\n        unlistenerFn = undefined;\n    }\n    return new Promise((resolve, reject) => {\n        function onStatusChange(statusResult) {\n            if (statusResult.error) {\n                cleanListener();\n                reject(statusResult.error);\n                return;\n            }\n            // install complete\n            if (statusResult.status === 'DONE') {\n                cleanListener();\n                resolve();\n            }\n        }\n        // listen status change\n        onUpdaterEvent(onStatusChange)\n            .then((fn) => {\n            unlistenerFn = fn;\n        })\n            .catch((e) => {\n            cleanListener();\n            // dispatch the error to our checkUpdate\n            throw e;\n        });\n        // start the process we dont require much security as it's\n        // handled by rust\n        emit(TauriEvent.INSTALL_UPDATE).catch((e) => {\n            cleanListener();\n            // dispatch the error to our checkUpdate\n            throw e;\n        });\n    });\n}\n/**\n * Checks if an update is available.\n * @example\n * ```typescript\n * import { checkUpdate } from '@tauri-apps/api/updater';\n * const update = await checkUpdate();\n * // now run installUpdate() if needed\n * ```\n *\n * @return Promise resolving to the update status.\n *\n * @since 1.0.0\n */\nasync function checkUpdate() {\n    let unlistenerFn;\n    function cleanListener() {\n        if (unlistenerFn) {\n            unlistenerFn();\n        }\n        unlistenerFn = undefined;\n    }\n    return new Promise((resolve, reject) => {\n        function onUpdateAvailable(manifest) {\n            cleanListener();\n            resolve({\n                manifest,\n                shouldUpdate: true\n            });\n        }\n        function onStatusChange(statusResult) {\n            if (statusResult.error) {\n                cleanListener();\n                reject(statusResult.error);\n                return;\n            }\n            if (statusResult.status === 'UPTODATE') {\n                cleanListener();\n                resolve({\n                    shouldUpdate: false\n                });\n            }\n        }\n        // wait to receive the latest update\n        once(TauriEvent.UPDATE_AVAILABLE, (data) => {\n            onUpdateAvailable(data?.payload);\n        }).catch((e) => {\n            cleanListener();\n            // dispatch the error to our checkUpdate\n            throw e;\n        });\n        // listen status change\n        onUpdaterEvent(onStatusChange)\n            .then((fn) => {\n            unlistenerFn = fn;\n        })\n            .catch((e) => {\n            cleanListener();\n            // dispatch the error to our checkUpdate\n            throw e;\n        });\n        // start the process\n        emit(TauriEvent.CHECK_UPDATE).catch((e) => {\n            cleanListener();\n            // dispatch the error to our checkUpdate\n            throw e;\n        });\n    });\n}\n\nexport { checkUpdate, installUpdate, onUpdaterEvent };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}